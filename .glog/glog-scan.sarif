{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-b7c761e1-2d81-4d5f-8769-af842477412e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow. This function copies a string from one buffer to another, but it does not guarantee that the destination buffer will be null-terminated, which can lead to buffer overflow if the size of the source string is greater than the size of the destination buffer. This can lead to unexpected behavior, including memory corruption and application crashes, and it can potentially be exploited to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `strncpy` and instead use safer string handling functions that guarantee null-termination and prevent buffer overflow. One such function is `strlcpy`, which is designed to be a safer, more consistent, and less error-prone replacement for `strncpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy`:\n\n```cpp\n#include <string.h>\n\nstrlcpy(buf, envStr, len);\n```\n\n## Library Dependencies\n\nThe `strncpy` function is part of the C standard library, so you need to include the `string.h` or `cstring` header file to use it. The `strlcpy` function is not part of the C standard library, but it is available on many Unix-like systems, including BSD and macOS. On systems where `strlcpy` is not available, you may need to implement it yourself or use a third-party library that provides it.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-dca333f3-09e4-4097-829c-5e1b21adc19a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(InfoString,ROCM_BUILD_INFO)`, the `strcpy` function is used to copy the `ROCM_BUILD_INFO` string into the `InfoString` buffer. If `ROCM_BUILD_INFO` is larger than `InfoString`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. These include `strncpy`, `strlcpy`, or `memcpy`. However, these functions can also be misused, so it's important to ensure that the size argument correctly represents the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(InfoString, ROCM_BUILD_INFO, sizeof(InfoString) - 1);\nInfoString[sizeof(InfoString) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(InfoString) - 1` characters from `ROCM_BUILD_INFO` to `InfoString`, and then manually null-terminate `InfoString`.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strncpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-cf841b5c-57ea-4120-ab89-217552f933c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when handling user input or data from untrusted sources. Consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(buf);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(buf, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen` from reading beyond the end of the buffer.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-b2fc35a3-6e0a-4946-97a8-26194099608b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to dynamically allocate memory at runtime. The problem arises when the size of the memory to be allocated is not properly validated or is manipulated in a way that leads to buffer overflow, underflow, or other memory corruption issues. This can lead to unexpected behavior, crashes, or even security vulnerabilities such as arbitrary code execution or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always validate the size of the memory to be allocated before calling `malloc`. This includes checking for potential integer overflows when calculating the size. Additionally, always check the return value of `malloc` to ensure that the memory allocation was successful. If `malloc` fails, it returns a null pointer, and any attempt to use this null pointer will lead to a crash.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\n#include <stdlib.h>\n\nif (lenstr > 0) {\n    cstr = (char*) malloc(lenstr * sizeof(char));\n    if (cstr == NULL) {\n        // Handle malloc failure (e.g., by returning or throwing an exception)\n    }\n} else {\n    // Handle invalid length (e.g., by returning or throwing an exception)\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-8ebf1195-c7d5-42d6-af09-352d486e07ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow or other memory corruption issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character (`'\\0'`) at the end, or by using functions that automatically null-terminate the string for you.\n\nAdditionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`. This function will stop reading memory after a certain number of characters, even if it hasn't encountered a null byte, preventing potential buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```cpp\nlen = strlen(envStr);\n```\n\nWith:\n\n```cpp\nlen = strnlen(envStr, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of `envStr`.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so you need to include the `string.h` header file:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-3473c4db-67e6-4a1a-90a3-5a7a19b25e8d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\nIn the provided code snippet, `strlen(ROCM_BUILD_INFO)`, the vulnerability arises if `ROCM_BUILD_INFO` is not a null-terminated string. This could lead to a buffer overflow vulnerability, which can be exploited to execute arbitrary code, crash the program, or cause other harmful effects.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. If the string comes from an untrusted source, validate and sanitize the input before using it. Avoid using `strlen` on strings of unknown length or origin.\n\n## Source Code Fix Recommendation\n\nIf `ROCM_BUILD_INFO` is a character array, ensure it is null-terminated:\n\n```cpp\nchar ROCM_BUILD_INFO[] = \"Some information\";\nROCM_BUILD_INFO[sizeof(ROCM_BUILD_INFO) - 1] = '\\0';\nsize_t length = strlen(ROCM_BUILD_INFO);\n```\n\nIf `ROCM_BUILD_INFO` is a pointer to a string, ensure the string it points to is null-terminated:\n\n```cpp\nchar* ROCM_BUILD_INFO = new char[100];\nstrncpy(ROCM_BUILD_INFO, \"Some information\", 99);\nROCM_BUILD_INFO[99] = '\\0';\nsize_t length = strlen(ROCM_BUILD_INFO);\ndelete[] ROCM_BUILD_INFO;\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-e83e3673-ad7c-434d-ab1c-b84a0f21d8f0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv`, `setenv`, or `unsetenv`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, you can use the `std::getenv` function which is safer and more secure.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdlib>\n\nconst char* envStr = std::getenv(\"ROCM_PATH\");\nif (envStr == nullptr) {\n    // Handle the case when the environment variable is not set.\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ea1f9b11-1b20-4718-bb0f-744d1e90a936",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory on the heap. If the allocation fails, `malloc` returns a null pointer. However, if the program does not check for this null pointer, it can lead to a null pointer dereference, which is a serious security vulnerability. This can lead to crashes, undefined behavior, and potential code execution vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the result of `malloc` to ensure it is not null before using the allocated memory. This can prevent null pointer dereferences and the associated security risks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\nbufPtr = (char *)malloc( LIBRARY_FILENAME_BUFSZ * sizeof(char) );\nif (bufPtr == NULL) {\n    // Handle error\n}\n```\n\nIn this code, we check if `bufPtr` is null after the `malloc` call. If it is, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerability Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-b7c761e1-2d81-4d5f-8769-af842477412e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_getpath.cpp"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 6,
                  "endLine": 115,
                  "endColumn": 31,
                  "charOffset": 4053,
                  "charLength": 25,
                  "snippet": {
                    "text": "strncpy(buf, envStr, len)",
                    "rendered": {
                      "text": "strncpy(buf, envStr, len)",
                      "markdown": "`strncpy(buf, envStr, len)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4053,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strcpy_s(buf,  len,  envStr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4053,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlcpy(buf,  envStr,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dca333f3-09e4-4097-829c-5e1b21adc19a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_version.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 1,
                  "endLine": 52,
                  "endColumn": 35,
                  "charOffset": 1164,
                  "charLength": 34,
                  "snippet": {
                    "text": "strcpy(InfoString,ROCM_BUILD_INFO)",
                    "rendered": {
                      "text": "strcpy(InfoString,ROCM_BUILD_INFO)",
                      "markdown": "`strcpy(InfoString,ROCM_BUILD_INFO)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_version.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1164,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strcpy_s(InfoString, <size of InfoString>, ROCM_BUILD_INFO)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_version.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1164,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlcpy(InfoString, ROCM_BUILD_INFO, <size of InfoString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cf841b5c-57ea-4120-ab89-217552f933c1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_getpath.cpp"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 8,
                  "endLine": 165,
                  "endColumn": 19,
                  "charOffset": 5503,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(buf)",
                    "rendered": {
                      "text": "strlen(buf)",
                      "markdown": "`strlen(buf)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5503,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(buf, <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5503,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(buf, <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b2fc35a3-6e0a-4946-97a8-26194099608b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_version.cpp"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 20,
                  "endLine": 68,
                  "endColumn": 46,
                  "charOffset": 1489,
                  "charLength": 26,
                  "snippet": {
                    "text": "malloc(lenstr*sizeof(char)",
                    "rendered": {
                      "text": "malloc(lenstr*sizeof(char)",
                      "markdown": "`malloc(lenstr*sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_version.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1489,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8ebf1195-c7d5-42d6-af09-352d486e07ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_getpath.cpp"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 10,
                  "endLine": 106,
                  "endColumn": 24,
                  "charOffset": 3830,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(envStr)",
                    "rendered": {
                      "text": "strlen(envStr)",
                      "markdown": "`strlen(envStr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3830,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(envStr, <size of envStr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3830,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(envStr, <size of envStr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3473c4db-67e6-4a1a-90a3-5a7a19b25e8d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_version.cpp"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 19,
                  "endLine": 40,
                  "endColumn": 42,
                  "charOffset": 893,
                  "charLength": 23,
                  "snippet": {
                    "text": "strlen(ROCM_BUILD_INFO)",
                    "rendered": {
                      "text": "strlen(ROCM_BUILD_INFO)",
                      "markdown": "`strlen(ROCM_BUILD_INFO)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_version.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 893,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strlen_s(ROCM_BUILD_INFO, <size of ROCM_BUILD_INFO>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_version.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 893,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strnlen(ROCM_BUILD_INFO, <size of ROCM_BUILD_INFO>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e83e3673-ad7c-434d-ab1c-b84a0f21d8f0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_getpath.cpp"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 16,
                  "endLine": 104,
                  "endColumn": 22,
                  "charOffset": 3703,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea1f9b11-1b20-4718-bb0f-744d1e90a936",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rocm_getpath.cpp"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 25,
                  "endLine": 69,
                  "endColumn": 70,
                  "charOffset": 2681,
                  "charLength": 45,
                  "snippet": {
                    "text": "malloc( LIBRARY_FILENAME_BUFSZ * sizeof(char)",
                    "rendered": {
                      "text": "malloc( LIBRARY_FILENAME_BUFSZ * sizeof(char)",
                      "markdown": "`malloc( LIBRARY_FILENAME_BUFSZ * sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rocm_getpath.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2681,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}